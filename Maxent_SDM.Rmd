---
title: "Maxent SDM using BioClim and Land Use data"
  
author: "Pablo Deschepper"
date: "`r Sys.Date()`"
output: html_document

params:
  Species:
    label: "Species:"
    value: "Vipera latastei"
    input: text
  Country:
    label: "2 letter country code (optional):"
    value: ""
    input: text
  Continent:
    label: "Continent (optional):"
    value: all
    input: select
    choices: [all, africa, antarctica, asia, europe, north_america, south_america, oceania]
  Database:
    label: "Database:"
    value: inaturalist
    input: select
    choices: [gbif, inaturalist, observation]
  Limit:
    label: "Max number of records:"
    value: "1000"
    input: numeric
  Workdir: 
    label: "Select your working directory:"
    value: "C:/Documents and Settings/pdeschepper/Desktop/Maxent"
    input: text
  ExportRaster:
    label: "Export raster objects for predictions:"
    value: "NO"
    input: select
    choices: ["NO", "YES"]
  Climate.model:
    label: "Select the CMIP6 climate model:"
    value: MPI-ESM1-2-HR
    input: select
    choices: [ACCESS-CM2, ACCESS-ESM1-5, AWI-CM-1-1-MR, BCC-CSM2-MR, CanESM5, CanESM5-CanOE, CMCC-ESM2, CNRM-CM6-1,CNRM-CM6-1-HR,CNRM-ESM2-1,EC-Earth3-Veg, EC-Earth3-Veg-LR, FIO-ESM-2-0, GFDL-ESM4, GISS-E2-1-G, GISS-E2-1-H, HadGEM3-GC31-LL, INM-CM4-8,INM-CM5-0,IPSL-CM6A-LR,MIROC-ES2L, MIROC6, MPI-ESM1-2-HR, MPI-ESM1-2-LR, MRI-ESM2-0, UKESM1-0-LL]
  SSP:
    label: "Select the SSP code:"
    value: 245
    input: select
    choices: [126, 245, 370, 585]
  Plot.xmin:
    label: "The numeric longitude minimum for SDM plots (optional):"
    value: ""
    input: numeric
  Plot.xmax:
    label: "The numeric longitude maximum for SDM plots (optional):"
    value: ""
    input: numeric
  Plot.ymin:
    label: "The numeric latitude minimum for SDM plots (optional):"
    value: ""
    input: numeric
  Plot.ymax:
    label: "The numeric latitude minimum for SDM plots (optional):"
    value: ""
    input: numeric
  

---

```{r setup, include = TRUE, eval = TRUE, echo = FALSE}
library(knitr)
knitr::opts_chunk$set(warning = FALSE, message = TRUE)
knitr::opts_knit$set(root.dir = params$Workdir)
logo_url <- "https://github.com/thesnakeguy/SDM_BioClim-and-LandUse/blob/main/Logo_SDM_resize.png?raw=true"
include_graphics(logo_url)
```
<br> 
<br> 
*This Markdown script was developed to model species distributions and ecological niches under both current and future climate conditions. The species distribution models (SDMs) for present-day conditions are trained using BioClim data, land use data, or a combination of both. For future projections, the models use BioClim data based on climate projections alone or combined with contemporary land use data.*<br>
*The modeled distributions reflect the species’ ecological niche, although several factors—such as dispersal barriers, geological history, and biotic interactions—may create differences between the realized and modeled niches.*<br>
*The script allows flexible model training, enabling users to specify geographic boundaries (country or continent) for occurrence data. Users can visualize the predicted species distribution or ecological niche within customized coordinate ranges, making this tool adaptable to various research needs. The script automatically removes strongly correlated (r > 0.75) predictors within the range of the species occurrences.*<br> 
<br> 
<br> 

- **Species = *`r params$Species`* **
- Using records from following database: `r params$Database`
- The number of records is limited to `r params$Limit` records
- Climate model for future predictions: `r params$Climate.model`
- Shared Socioeconomic Pathway (SSP): `r params$SSP`  

The working directory = *`r params$Workdir`*<br>


note: The script will download all BioClim and Land Use data upon first use of the script, translating into a longer processing times. The script will run faster after first use.

```{r libraries, include=FALSE}
library(dismo)
library(raster)
library(rgbif)
library(sf)
library(rmaxent)
library(rJava)
library(rasterVis)
library(viridis)
library(geodata)
library(ggplot2)
library(stringr)
library(rnaturalearth)
library(caret)
library(dichromat)
library(dplyr)
library(kableExtra)
```

```{r Get species records, include=FALSE, echo=FALSE}

#### Search for species occurrences in GBIF ####
# this option is straighforward but does not allow a lot of options
ContinentParam <- NULL
if (params$Continent == "all") {
  ContinentParam <- ""} else {ContinentParam <- params$Continent}

occurrences <- rgbif::occ_data(scientificName = params$Species,
                              limit = params$Limit,
                              hasCoordinate = TRUE,
                              hasGeospatialIssue = FALSE,
                              coordinateUncertaintyInMeters = '0,250',
                              country = params$Country,
                              continent = ContinentParam)
if (params$Database == "inaturalist") {
  occurrences <- data.frame(occurrences$data[, c("decimalLongitude", "decimalLatitude", "occurrenceID")])
  occurrences <- occurrences[str_detect(occurrences$occurrenceID, "inaturalist"),] %>% na.omit()
  recs <- nrow(occurrences)
  print(paste("Using",recs,"inaturalist records"))
  } else if (params$Database == "observation") {
    occurrences <- data.frame(occurrences$data[, c("decimalLongitude", "decimalLatitude", "occurrenceID")])
    occurrences <- occurrences[str_detect(occurrences$occurrenceID, "observation.org"),] %>% na.omit()
    recs <- nrow(occurrences)
    print(paste("Using",recs,"observation.org records"))
  } else {
    occurrences <- data.frame(occurrences$data[, c("decimalLongitude", "decimalLatitude", "occurrenceID")]) %>% na.omit()
    recs <- nrow(occurrences)
    print(paste("Using",recs,"gbif records"))
  }
  
if (recs < 50) {
  stop("Fewer than 50 species records: Process aborted.")
}

# Create a SpatialPointsDataFrame object for the occurrence data
spdf <- SpatialPointsDataFrame(coords = occurrences[, c("decimalLongitude", "decimalLatitude")], data = occurrences)
# Bounding box of distribution
bbox <- st_bbox(spdf) 
points <- data.frame(occurrences[, c("decimalLongitude", "decimalLatitude")])
```

```{r (Down)Load BioClim and Land Use data, include=TRUE, echo=FALSE}

#### Load BioClimatic data ####
# Create an extent object for the study area using bounding box coordinates
# By adding 2, we add 1 degree at each side
study_area_ext <- extent(bbox)*1.25
# Create a raster object for the study area
study_area_ras <- raster::raster(study_area_ext)
# Set the resolution of the raster
res(study_area_ras) <- 10
# Download the BioClim data for the study area: PRESENT
# Check if the path exists
if (!dir.exists("worldclim_data")) {
  # Download WorldClim data if the directory does not exist
  dir.create("worldclim_data")
  worldclim_data <- geodata::worldclim_global(var = 'bio', res = 10, download = TRUE, path = "worldclim_data")
  print("BioClim data has been downloaded and saved to the working directory.")
} else {
  print("BioClim data already exists and was loaded from the working directory.")
  rast_list <- c(list.files("worldclim_data/climate/wc2.1_10m/", full.names = TRUE)) %>%
    .[grepl("bio_([1-9]|1[0-9])", .)]
  worldclim_data <- terra::rast(rast_list)
  }
# convert from SpatRaster to Raster object while keeping all layers
worldclim_data_raster <- as(worldclim_data, "Raster")
# rename bio variables
names(worldclim_data_raster) <- gsub("wc2.1_10m_", "", names(worldclim_data_raster))

#Download BioClim data for two future time periods
fut <- geodata::cmip6_world(model=params$Climate.model, ssp=params$SSP, time='2041-2060', var='bioc', download=F, res=10, path='worldclim_data')
fut2 <- geodata::cmip6_world(model=params$Climate.model, ssp=params$SSP, time='2061-2080', var='bioc', download=F, res=10, path='worldclim_data')
fut <- as(fut, "Raster")
fut2 <- as(fut2, "Raster")
names(fut) <- str_replace(names(fut), "bio0?(\\d+)", "bio_\\1")
names(fut2) <- str_replace(names(fut2), "bio0?(\\d+)", "bio_\\1")
```

```{r Load Land Use data , include=FALSE}

### load land use data ####
elevation <- geodata::elevation_global(path = "Elevation", res = 10)
footprint <- geodata::footprint(year = 2009, path = "Footprint")
population <- geodata::population(year = 2020, path = "Population", res = 10)
trees <- geodata::landcover(var = "trees", path = "Trees")
grassland <- geodata::landcover(var = "grassland", path = "Grassland")
shrubs <- geodata::landcover(var = "shrubs", path = "Shrubs")
built <- geodata::landcover(var = "built", path = "Built")
bare <- geodata::landcover(var = "bare", path = "Bare")
wetland <- geodata::landcover(var = "wetland", path = "Wetland")
water <- geodata::landcover(var = "water", path = "Water")


# make everything 10-min spatial resolution (not the case for land cover and footprints which are in 30-second res)
# and crop to study area
rescale_aggregate <- function(raster) {
  rescaled <- terra::aggregate(raster, fact = 20, fun = 'mean') %>% crop(extent(-180, 180, -60, 84)) # this is the limiting extent of landuse objects
  rasterized <- raster::raster(rescaled)
  # resampled <- terra::resample(rasterized, study_area_ras)
  return(rasterized)
}
crop_to_small <- function(raster) {
  rescaled <- raster %>% crop(extent(-180, 180, -60, 84)) # this is the limiting extent of landuse objects
  rasterized <- raster::raster(rescaled)
  # resampled <- terra::resample(rasterized, study_area_ras)
  return(rasterized)
}
trees_rc <- rescale_aggregate(trees)
grassland_rc <- rescale_aggregate(grassland)
shrubs_rc <- rescale_aggregate(shrubs)
built_rc <- rescale_aggregate(built)
bare_rc <- rescale_aggregate(bare)
water_rc <- rescale_aggregate(water)
wetland_rc <- rescale_aggregate(wetland)
footprint_rc <- rescale_aggregate(footprint)
elevation_rc <- crop_to_small(elevation) # aleady in 10 res
population_rc <- crop_to_small(population) # aleady in 10 res
names(footprint_rc) <- c("human.footprint") # this name was awkwardly long
names(elevation_rc) <- c("elevation") # this name was awkwardly long
names(population_rc) <- c("population") # this name was awkwardly long


# combine all of the landuse rasters into a rasterbrick
landuse <- c(trees_rc, grassland_rc, shrubs_rc, built_rc, bare_rc, footprint_rc,
             elevation_rc, population_rc, water_rc, wetland_rc) 
landuse_rasterbrick <- do.call(stack, landuse)

```



## Species records
This plot shows the georeferenced species records that will be used to train the Species Distribution Models (SDM) using MaxEnt. It is good to maximize the number of records.

**`r recs` records** of `r params$Species` are used for processing (georeference obscurity < 250m).

```{r Records plot, include=TRUE, echo=FALSE}
all_countries <- rnaturalearth::ne_countries(scale = "medium", returnclass = "sf")
ggplot() + geom_point(data = points, aes(x=decimalLongitude, y = decimalLatitude), col="red") +
  geom_sf(data = all_countries, fill = "transparent", color="black") +
  coord_sf(xlim = c(bbox$xmin, bbox$xmax), ylim = c(bbox$ymin, bbox$ymax), expand = TRUE) + theme_bw()
```


```{r Combine BoiClim and Land use data into predictors, include=FALSE}
### Make predictors dataset ####
# aggregate bioclimatic and land use date in one dataset
# align the extents
worldclim_data_aligned <- crop(worldclim_data_raster, extent(landuse_rasterbrick))
# resample to match resolution
if(!all(res(worldclim_data_aligned) == res(landuse_rasterbrick))) {
  worldclim_data_aligned <- resample(worldclim_data_aligned, landuse_rasterbrick, method = 'bilinear')
}
predictors <- stack(c(worldclim_data_aligned, landuse_rasterbrick))
fut_predictors <- stack(c(crop(fut, extent(landuse_rasterbrick)), landuse_rasterbrick))
fut2_predictors <- stack(c(crop(fut2, extent(landuse_rasterbrick)), landuse_rasterbrick))
```

```{r Clean the Full, BioClim and Land Use dataset by removing correlation, include=FALSE}
# Clean dataset for correlation > 0.75
datasets <- list(predictors = predictors, 
                 worldclim_data_aligned = worldclim_data_aligned, 
                 landuse_rasterbrick = landuse_rasterbrick)
cleaned_datasets <- list()
# Loop through each dataset and remove highly correlated variables within the range of the species -> there could be correlation within the region, but not worldwide!
for (dataset_name in names(datasets)) {
  dataset_df <- crop(datasets[[dataset_name]], study_area_ext) %>% as.data.frame(na.rm = TRUE)
  cor_mat <- cor(dataset_df, method = 'spearman', use = 'complete.obs')
  highly_correlated <- findCorrelation(cor_mat, cutoff = 0.75)
  # Only remove layers if there are correlated layers to remove
  if (length(highly_correlated) > 0) {
    cleaned_dataset <- datasets[[dataset_name]][[ -highly_correlated ]]
  } else {
    cleaned_dataset <- datasets[[dataset_name]]
  }
  cleaned_datasets[[dataset_name]] <- cleaned_dataset
  print(paste("Cleaned layers in", dataset_name, ":"))
  print(names(cleaned_dataset))
}

# Access the cleaned datasets
predictors_cleaned <- cleaned_datasets$predictors
worldclim_data_aligned_cleaned <- cleaned_datasets$worldclim_data_aligned
landuse_rasterbrick_cleaned <- cleaned_datasets$landuse_rasterbrick
# Also subset (clean) the future BioClim data and combine to full predictors set
fut_bioclim_cleaned <- fut[[names(worldclim_data_aligned_cleaned)]]
fut2_bioclim_cleaned <- fut2[[names(worldclim_data_aligned_cleaned)]]
fut_predictors_cleaned <- fut_predictors[[names(predictors_cleaned)]]
fut2_predictors_cleaned <- fut2_predictors[[names(predictors_cleaned)]]

```


```{r Run the maxent models, include=FALSE, echo=FALSE}
#### create test and train data ####
# Now let us divide this file into 5 parts. 75% of the data will be used to train the model (to create the mode), and 25% will be used to test if it is a good model.
group <- kfold(points,5)
pres_train <- points[group!=1,]
pres_test <- points[group==1,]

#### modeling predictor contribution with maxent and create pseudo-absences ####
# cross-validation (default) with 10 replicates
model_full <- maxent(predictors_cleaned, pres_train, removeDuplicates = TRUE, replicates = 10)
model_bioclim <- maxent(worldclim_data_aligned_cleaned, pres_train, removeDuplicates = TRUE, replicates = 10)
model_landuse <- maxent(landuse_rasterbrick_cleaned, pres_train, removeDuplicates = TRUE, replicates = 10)

# create pseudo-absences to evaluate the model using AUC
predictorset <- c(predictors_cleaned, worldclim_data_aligned_cleaned, landuse_rasterbrick_cleaned)
models <- c(model_full, model_bioclim, model_landuse)
plot_titles <- c("Full model", "BioClim model", "Land Use model")

evalplots <- list()
e.metrics <- list()
AUC <- c()
for (i in c(1:length(models))) {
  backg = randomPoints(predictorset[[i]], n=10000, ext = study_area_ext, extf=1.25)
  colnames(backg) <- c("lon","lat")
  group=kfold(backg, 5)
  backg_train <- backg[group!=1,]
  backg_test <- backg[group==1,]
  e = evaluate(pres_test, backg_test, models[[i]], predictorset[[i]])
  e.metrics[[i]] <- e
  # Extract TPR and FPR for ROC curve
  TPR <- e@TPR  # True Positive Rate
  FPR <- e@FPR  # False Positive Rate
  AUC <- round(e@auc, 3)
  # Store the ROC plot as a ggplot object in evalplots
  evalplots[[i]] <- ggplot() +
    geom_line(aes(x = FPR, y = TPR), color = "blue") +
    xlab("False Positive Rate") + 
    ylab("True Positive Rate") +
    labs(title = plot_titles[i],
         subtitle = paste("AUC =",AUC)) +
    theme_minimal()
}
```

# MaxEnt SDM: the models {.tabset}
## Predictor contributions for every model

 - *Full model*: This model includes all 19 BioClim variables all land use variables as predictors.
 - *BioClim model*: This model exclusively uses the BioClim variables to train the model.
 - *Land Use model*: This model exclusively uses the land use variables to train the model.<br>
 
 All models are employed with 10-fold cross validation.
 
**BioClimatic variables**<br>
BIO1 = Annual Mean Temperature<br>
BIO2 = Mean Diurnal Range (Mean of monthly (max temp - min temp))<br>
BIO3 = Isothermality (BIO2/BIO7) (×100)<br>
BIO4 = Temperature Seasonality (standard deviation ×100)<br>
BIO5 = Max Temperature of Warmest Month<br>
BIO6 = Min Temperature of Coldest Month<br>
BIO7 = Temperature Annual Range (BIO5-BIO6)<br>
BIO8 = Mean Temperature of Wettest Quarter<br>
BIO9 = Mean Temperature of Driest Quarter<br>
BIO10 = Mean Temperature of Warmest Quarter<br>
BIO11 = Mean Temperature of Coldest Quarter<br>
BIO12 = Annual Precipitation<br>
BIO13 = Precipitation of Wettest Month<br>
BIO14 = Precipitation of Driest Month<br>
BIO15 = Precipitation Seasonality (Coefficient of Variation)<br>
BIO16 = Precipitation of Wettest Quarter<br>
BIO17 = Precipitation of Driest Quarter<br>
BIO18 = Precipitation of Warmest Quarter<br>
BIO19 = Precipitation of Coldest Quarter

**Land use variables**<br>
Values are the fraction of a landcover class in each cell. The values are derived from the ESA WorldCover data set at 0.3-seconds resolution.<br>
Landcover variables:<br>
  - Trees<br>
  - Grassland<br> 
  - Shrubs<br>
  - Water<br>
  - Wetland<br>
  - Bare<br>
  - Built<br>
Following variables are also included:<br>
  - Population density<br>
  - Human footprint<br>
  - Elevation

more info on: https://github.com/rspatial/geodata

```{r Plotting predictor contributions, include=TRUE, echo=FALSE}
par(mfrow = c(3, 1), mar = c(2, 10, 1.5, 1))
terra::plot(model_full, main = "Full model") 
terra::plot(model_bioclim, main = "BioClim model")
terra::plot(model_landuse, main = "Land Use model")
par(mfrow = c(1,1))
```

Predictors within every model have been purged for correlation if r > 0.75. When pairwise correlation is detected above this threshold, one of the variables within the pair is omitted before further processing.


### Partial response curve

For each predictor the fitted species-environment relationship is plotted along the entire gradient while keeping the other predictors at their mean value. Partial response plots are oversimplifications and therefore hard to interpret as they do not represent the full species-environment relationship.

#### Full model

```{r Plotting predictor response curve: full model, include=TRUE, echo=FALSE}
# Function to plot response curves for a given model
plot_response_curves <- function(model) {
  # Set up the plotting layout
  par(mfrow = c(3, ceiling(length(names(model@presence)) / 3)), mar = c(4, 4, 2, 1))
  
  # Loop through predictors and plot response curves with titles
  for (var in names(model@presence)) {
    dismo::response(model, var = var, range = 'p', col = "grey", lwd = 4, expand = 0)
    # title(main = var)
  }
  # Reset plotting layout back to default
  par(mfrow = c(1, 1))
}
plot_response_curves(model_full)
```

#### BioClim model

```{r Plotting predictor response curve: BioClim model, include=TRUE, echo=FALSE}
plot_response_curves(model_bioclim)
```

#### Land Use model

```{r Plotting predictor response curve: Land Use model, include=TRUE, echo=FALSE}
plot_response_curves(model_landuse)
```


## Model validation

In order to validate the models, 75% of the data is kept to train the MaxEnt (Maximum Entropy) models, while the remaining 25% is kept aside for model validation.
The ROC curve is drawn by calculating the true positive rate (TPR) and false positive rate (FPR) at every possible threshold, then graphing TPR over FPR. A perfect model has a TPR of 1.0 and a FPR of 0.0. The larger the Area Under the Curve (AUC), the better a model performs.

```{r Plotting model accuracy, include=TRUE, echo=FALSE}
cowplot::plot_grid(plotlist = evalplots, ncol = 3)
```

Metrics for model evaluation:

```{r Print model evaluation metrics, include=TRUE, echo=FALSE}
names(e.metrics) <- c("Full model","BioClim model","Land use model")
print(e.metrics[1:length(models)])
```


```{r Maxent predictions, include=FALSE, echo=FALSE}
#### Create a map of the predicted distributions in the present and future ####
# Extent of predictions
bbox.plot <- c(as.numeric(params$Plot.xmin), as.numeric(params$Plot.xmax), 
                as.numeric(params$Plot.ymin), as.numeric(params$Plot.ymax))
ext.pred <- ""
if (length(bbox.plot) != 4 || any(is.na(bbox.plot))) {
  ext.pred <- study_area_ext
} else {
  ext.pred <- raster::extent(bbox.plot)
}

# PRESENT SDM for all predictors, bioclim only and landuse only
present_full <- predict(x = predictors_cleaned, object = model_full, ext = ext.pred, progress='')
present_bioclim <- predict(x = worldclim_data_aligned_cleaned, object = model_bioclim, ext = ext.pred, progress='')
present_landuse <- predict(x = landuse_rasterbrick_cleaned, object = model_landuse, ext = ext.pred, progress='')

# FUTURE SDM for future BioClim predictors, future BioClim combined with contemporary land use
fut_bioclim_pred <- predict(fut_bioclim_cleaned, model_bioclim, ext = ext.pred, progress='', na.rm = TRUE)
fut2_bioclim_pred <- predict(fut2_bioclim_cleaned, model_bioclim, ext = ext.pred, progress='', na.rm = TRUE)
fut_full_pred <- predict(fut_predictors_cleaned, model_full, ext = ext.pred, progress='', na.rm = TRUE)
fut2_full_pred <- predict(fut2_predictors_cleaned, model_full, ext = ext.pred, progress='', na.rm = TRUE)

```


# MaxEnt SDM: plots {.tabset}

## Present

### SDM using BioClim and land use data


```{r, plotting the present 1/3, include=TRUE, echo=FALSE}
# Get elevation data (this code here is to add a elevation layer as the bottom layer if wanted)
# slope <- terra::terrain(elevation_rc, "slope", unit="radians")
# aspect <- terra::terrain(elevation_rc, "aspect", unit="radians")
# hill <- terra::shade(slope, aspect, 45, 270)
# all_countries <- rnaturalearth::ne_countries(scale = "medium", returnclass = "sf")

# plot(hill, col=grey(0:100/100), legend=FALSE, mar=c(2,2,1,4),
#      xlim = c(ext.pred@xmin, ext.pred@xmax),
#      ylim = c(ext.pred@ymin, ext.pred@ymax))
raster::plot(present_full, col = terrain.colors(25, alpha = 0.3, rev = TRUE))
title(bquote('MaxEnt full model ' * italic(.(params$Species))))
# shapefile of countries
plot(all_countries, add = TRUE, col = "transparent", border = "black")
# add occurrences with correct projection
plot(spdf, add = TRUE, pch = 16, cex = 0.5, col = rgb(red = 0, green = 0, blue = 1, alpha = 0.4))
```

### SDM using BioClim data only


```{r, plotting the present 2/3, include=TRUE, echo=FALSE}
# plot(hill, col=grey(0:100/100), legend=FALSE, mar=c(2,2,1,4),
#      xlim = c(ext.pred@xmin, ext.pred@xmax),
#      ylim = c(ext.pred@ymin, ext.pred@ymax))
raster::plot(present_bioclim, col = terrain.colors(25, alpha = 0.3, rev = TRUE))
title(bquote('MaxEnt BioClim model ' * italic(.(params$Species))))
# shapefile of countries
plot(all_countries, add = TRUE, col = "transparent", border = "black")
# add occurrences with correct projection
plot(spdf, add = TRUE, pch = 16, cex = 0.5, col = rgb(red = 0, green = 0, blue = 1, alpha = 0.4))
```

### SDM using land use data only


```{r, plotting the present 3/3, include=TRUE, echo=FALSE}
# plot(hill, col=grey(0:100/100), legend=FALSE, mar=c(2,2,1,4),
#      xlim = c(ext.pred@xmin, ext.pred@xmax),
#      ylim = c(ext.pred@ymin, ext.pred@ymax))
raster::plot(present_landuse, col = terrain.colors(25, alpha = 0.3, rev = TRUE))
title(bquote('MaxEnt landuse model ' * italic(.(params$Species))))
# shapefile of countries
plot(all_countries, add = TRUE, col = "transparent", border = "black")
# add occurrences with correct projection
plot(spdf, add = TRUE, pch = 16, cex = 0.5, col = rgb(red = 0, green = 0, blue = 1, alpha = 0.4))

```

## Future

### SDM using future BioClim data and contemporary land use data combined


```{r, plotting the future 2/2, include=TRUE, echo=FALSE}
# plot(hill, col=grey(0:100/100), legend=FALSE, mar=c(2,2,1,4),
#      xlim = c(ext.pred@xmin, ext.pred@xmax),
#      ylim = c(ext.pred@ymin, ext.pred@ymax))
raster::plot(fut_full_pred, col = terrain.colors(25, alpha = 0.3, rev = TRUE))
title(bquote('MaxEnt full model ' * italic(.(params$Species)) * ' : 2041-2060'))
plot(all_countries, add = TRUE, col = "transparent", border = "black")
plot(spdf, add = TRUE, pch = 16, cex = 0.5, col = rgb(red = 0, green = 0, blue = 1, alpha = 0.4))

# plot(hill, col=grey(0:100/100), legend=FALSE, mar=c(2,2,1,4),
#     xlim = c(ext.pred@xmin, ext.pred@xmax),
#      ylim = c(ext.pred@ymin, ext.pred@ymax))
raster::plot(fut2_full_pred, col = terrain.colors(25, alpha = 0.3, rev = TRUE))
title(bquote('MaxEnt full model ' * italic(.(params$Species)) * ' : 2061-2080'))
plot(all_countries, add = TRUE, col = "transparent", border = "black")
plot(spdf, add = TRUE, pch = 16, cex = 0.5, col = rgb(red = 0, green = 0, blue = 1, alpha = 0.4))
```


### SDM using future BioClim data


```{r, plotting the future 1/2, include=TRUE, echo=FALSE}
# plot(hill, col=grey(0:100/100), legend=FALSE, mar=c(2,2,1,4),
#      xlim = c(ext.pred@xmin, ext.pred@xmax),
#      ylim = c(ext.pred@ymin, ext.pred@ymax))
raster::plot(fut_bioclim_pred, col = terrain.colors(25, alpha = 0.3, rev = TRUE))
title(bquote('MaxEnt BioClim model ' * italic(.(params$Species)) * ' : 2041-2060'))
plot(all_countries, add = TRUE, col = "transparent", border = "black")
plot(spdf, add = TRUE, pch = 16, cex = 0.5, col = rgb(red = 0, green = 0, blue = 1, alpha = 0.4))

# plot(hill, col=grey(0:100/100), legend=FALSE, mar=c(2,2,1,4),
#     xlim = c(ext.pred@xmin, ext.pred@xmax),
#      ylim = c(ext.pred@ymin, ext.pred@ymax))
raster::plot(fut2_bioclim_pred, col = terrain.colors(25, alpha = 0.5, rev = TRUE))
title(bquote('MaxEnt BioClim model ' * italic(.(params$Species)) * ' : 2061-2080'))
plot(all_countries, add = TRUE, col = "transparent", border = "black")
plot(spdf, add = TRUE, pch = 16, cex = 0.5, col = rgb(red = 0, green = 0, blue = 1, alpha = 0.4))
```

## SDM change

### Change in climatic niche

Change in climatic niche using BioClim predictors between the current climate and future climate. Range expansion is indicated in blue, reduction is indicated in red. Below each geographical plot, a barplot shows the percentage of species records within the estimated contracting (red) or expanding (blue) range under future climatic conditions.



```{r, plotting the change (1/2), include=TRUE, echo=FALSE}
# CHANGE
# calculate change: negative = loss, positive = gain
change <- fut_bioclim_pred-present_bioclim
change2 <- fut2_bioclim_pred-present_bioclim
colrange <- colorRampPalette(c("darkred", "white", "darkblue"))

# plot change raster object 
raster::plot(change, col = colrange(255), zlim = c(-1, 1))
title(bquote('Response to climate change ' * italic(.(params$Species)) * ' : 2041-2060'))
plot(all_countries, add = TRUE, col = "transparent", border = "black")
# plot barplot
neg_change <- change < 0
pos_change <- change > 0
neg_change.points <- extract(neg_change, spdf) %>% na.omit() %>% sum()
pos_change.points <- extract(pos_change, spdf) %>% na.omit() %>% sum()
negpos_change.perc <- c(pos_change.points/sum(neg_change.points + pos_change.points), neg_change.points/sum(neg_change.points + pos_change.points))
change_df <- data.frame(Change = c("Positive", "Negative"), Proportion = negpos_change.perc)
ggplot(data = change_df, aes(x = "", y = Proportion, fill = Change)) + 
  geom_bar(stat = "identity", width = 0.1, color = "white", show.legend = FALSE, position =  position_fill(reverse = TRUE)) + 
  scale_fill_manual(values = c("Negative" = "tomato", "Positive" = "skyblue")) +
  geom_text(aes(label = round(Proportion,2)), size = 6, position = position_stack(vjust = 0.5, reverse = TRUE), color = "Black") +
  coord_flip() +
  theme_void()



# plot change2 raster object
raster::plot(change2, col = colrange(255), zlim = c(-1, 1))
title(bquote('Response to climage change ' * italic(.(params$Species)) * ' : 2061-2080'))
plot(all_countries, add = TRUE, col = "transparent", border = "black")
# plot barplot
neg_change <- change2 < 0
pos_change <- change2 > 0
neg_change.points <- extract(neg_change, spdf) %>% na.omit() %>% sum()
pos_change.points <- extract(pos_change, spdf) %>% na.omit() %>% sum()
negpos_change.perc <- c(pos_change.points/sum(neg_change.points + pos_change.points), neg_change.points/sum(neg_change.points + pos_change.points))
change_df <- data.frame(Change = c("Positive", "Negative"), Proportion = negpos_change.perc)
ggplot(data = change_df, aes(x = "", y = Proportion, fill = Change)) + 
  geom_bar(stat = "identity", width = 0.1, color = "white", show.legend = FALSE, position =  position_fill(reverse = TRUE)) + 
  scale_fill_manual(values = c("Negative" = "tomato", "Positive" = "skyblue")) +
  geom_text(aes(label = round(Proportion,2)), size = 6, position = position_stack(vjust = 0.5, reverse = TRUE), color = "Black") +
  coord_flip() +
  theme_void()
```

### Limiting variables

The variable most responsible for unfavorable conditions in respect of the species' climatic niche in the future (2041-2060) is plotted for every grid cell. 
<br>
<br>

```{r, plotting the limiting factors, include=TRUE, echo=FALSE}
lim <- rmaxent::limiting(raster::crop(fut_bioclim_cleaned, ext.pred), model_bioclim)
rasterVis::levelplot(lim, col.regions = rainbow, main = "Limiting variables under future climatic conditions (2041-2060)") 

# Limiting predictors
lim2 <- rmaxent::limiting(raster::crop(fut2_bioclim_cleaned, ext.pred), model_bioclim)
rasterVis::levelplot(lim2, col.regions = rainbow, main = "Limiting variables under future climatic conditions (2041-2060)")

```

This table shows the relative contribution of every BioClim predictor to the species' climatic niche contraction where the strength of range reducion is > -0.1. (present vs 2041-2060). The relative contribution is estimated by: <br>
1) Extracting the limiting predictor variables that overlap with a value lower than -0.1 for range contraction.<br>
2) Overlaying the species' spatial occurrence points with the extracted raster image from step 1 and count the relative
   contribution of every predictor variable.
<br>

```{r, plotting a table for limiting factors, include=TRUE, echo=FALSE}
# Estimate which limiting variables contribute to the species' climatic niche contraction
Limiting_Predictors <- function(ChangeRaster, LimitRaster, SpatPoints, NegChange_limit = -0.1) {
  # Identify areas of negative change
  negative_change <- ChangeRaster < NegChange_limit
  # Mask the LimitRaster to show only negative change areas
  lim_masked <- LimitRaster
  lim_masked[!negative_change] <- NA
  # Extract raster values at each spatial point
  spdf_values <- extract(lim_masked, SpatPoints)
  # Create a summary data frame with counts of each raster value
  summary_df <- table(spdf_values) %>% as.data.frame()
  # Retrieve the attribute table with predictor names
  attribute_table <- lim_masked@data@attributes[[1]]
  # Map raster values to predictors
  summary_df$spdf_values <- setNames(attribute_table$predictor[match(summary_df$spdf_values, attribute_table$ID)], 
                                     summary_df$spdf_values)
  # Rename columns for clarity
  names(summary_df) <- c("Predictor", "Freq")
  # Add relative percentage column and order by frequency
  summary_df <- summary_df %>%
    mutate(Perc = round((as.numeric(Freq) / sum(as.numeric(Freq))) * 100, 2)) %>%
    arrange(desc(Freq))
  # Output the summary table with kable for a clear display
  kable(summary_df, caption = "Relative Contribution of Predictors for Negative Change Areas") %>%
  kable_paper("hover", full_width = F)
}
Limiting_Predictors(ChangeRaster = change, LimitRaster = lim, SpatPoints = spdf, NegChange_limit = -0.1)

```

```{r, exporting raster objects if ExportRaster is TRUE, include=TRUE, echo=FALSE}
# Create directory
if (!dir.exists(file.path(params$Workdir, "Raster_objects")) & params$ExportRaster == "YES") {  dir.create(file.path(params$Workdir,"Raster_objects"), recursive = TRUE)}

# Export relevant raster objects
if (params$ExportRaster == "YES") {
  setwd(dir = file.path(params$Workdir,"Raster_objects"))
    # Present: full model (consistently has the highest AUC)
    raster::writeRaster(x = present_full, filename = paste0(params$Species, "_Present_FullModel"), overwrite = TRUE)
    # Future 1: BioClim
    raster::writeRaster(x = fut_bioclim_pred, filename = paste0(params$Species, "_Future_BioClim"), overwrite = TRUE)
    # Future 2: BioClim
    raster::writeRaster(x = fut2_bioclim_pred, filename = paste0(params$Species, "_Future2_BioClim"), overwrite = TRUE)
    # Change 1
    raster::writeRaster(x = change, filename = paste0(params$Species, "_Change"), overwrite = TRUE)
    # Change 2
    raster::writeRaster(x = change2, filename = paste0(params$Species, "_Change2"), overwrite = TRUE)
  setwd(dir = params$Workdir)
}
```
<br>
<br>
<br>
<br>
